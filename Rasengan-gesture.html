<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Naruto AR: Realistic Whiskers</title>
    
    <!-- MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            background-color: #111;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        #input_video {
            position: absolute;
            transform: scaleX(-1); 
            display: none;
        }

        #output_canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #ui-layer {
            position: absolute;
            z-index: 10;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        #start-btn {
            background: linear-gradient(135deg, #FF8C00 0%, #FF4500 100%);
            border: 2px solid #fff;
            padding: 15px 50px;
            color: white;
            font-size: 22px;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.6);
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: transform 0.2s;
        }

        #start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(255, 69, 0, 0.9);
        }

        #loading {
            display: none;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            margin-top: 10px;
        }
    </style>
</head>
<body>

<div id="container">
    <video id="input_video"></video>
    <canvas id="output_canvas"></canvas>
    
    <div id="ui-layer">
        <button id="start-btn" onclick="startApp()">Focus Chakra</button>
        <div id="loading">Syncing Chakra Network...</div>
    </div>
</div>

<script>
/**
 * CONFIGURATION
 */
const config = {
    // High Quality Rasengan Settings
    rasengan: {
        colorCore: '#E0FFFF',
        colorInner: '#00FFFF',
        colorOuter: '#0088FF',
        maxSize: 120, 
        growthSpeed: 0.15, 
        shrinkSpeed: 0.2
    },
    // Leaf Shinobi Headband Settings
    headband: {
        clothColor: '#0c1c38', // Standard Navy Blue
        symbolColor: '#1a1a1a' // Dark Grey
    }
};

// Precise Leaf Village Symbol Contour
const leafPoints = [
    {x: 0.4952, y: -0.3941}, {x: 0.4666, y: -0.4244}, {x: 0.4459, y: -0.4244},
    {x: 0.3471, y: -0.3145}, {x: 0.3185, y: -0.2938}, {x: 0.2978, y: -0.2954},
    {x: 0.2484, y: -0.3177}, {x: 0.1768, y: -0.3384}, {x: 0.0812, y: -0.3447},
    {x: 0.0334, y: -0.3384}, {x: -0.0255, y: -0.3209}, {x: -0.1131, y: -0.2699},
    {x: -0.1895, y: -0.1919}, {x: -0.2914, y: -0.0374}, {x: -0.3519, y: 0.0725},
    {x: -0.4968, y: 0.3654}, {x: -0.5000, y: 0.3925}, {x: -0.4809, y: 0.4037},
    {x: -0.0303, y: 0.4228}, {x: 0.1401, y: 0.4244}, {x: 0.1895, y: 0.4212},
    {x: 0.2436, y: 0.4100}, {x: 0.3057, y: 0.3846}, {x: 0.3439, y: 0.3591},
    {x: 0.3901, y: 0.3129}, {x: 0.4268, y: 0.2508}, {x: 0.4443, y: 0.1919},
    {x: 0.4475, y: 0.1154}, {x: 0.4347, y: 0.0518}, {x: 0.4045, y: -0.0167},
    {x: 0.3758, y: -0.0581}, {x: 0.3137, y: -0.1107}, {x: 0.2707, y: -0.1314},
    {x: 0.2150, y: -0.1457}, {x: 0.1545, y: -0.1473}, {x: 0.1051, y: -0.1377},
    {x: 0.0605, y: -0.1186}, {x: 0.0223, y: -0.0916}, {x: -0.0111, y: -0.0533},
    {x: -0.0366, y: -0.0040}, {x: -0.0446, y: 0.0295}, {x: -0.0446, y: 0.0740},
    {x: -0.0239, y: 0.1330}, {x: 0.0096, y: 0.1712}, {x: 0.0287, y: 0.1839},
    {x: 0.0701, y: 0.2014}, {x: 0.0987, y: 0.2062}, {x: 0.1481, y: 0.2014},
    {x: 0.1990, y: 0.1744}, {x: 0.2245, y: 0.1425}, {x: 0.2373, y: 0.1154},
    {x: 0.2420, y: 0.0629}, {x: 0.2309, y: 0.0279}, {x: 0.2150, y: 0.0024},
    {x: 0.1990, y: -0.0104}, {x: 0.1783, y: -0.0104}, {x: 0.1592, y: 0.0072},
    {x: 0.1879, y: 0.0709}, {x: 0.1863, y: 0.0932}, {x: 0.1720, y: 0.1202},
    {x: 0.1529, y: 0.1346}, {x: 0.1226, y: 0.1425}, {x: 0.0908, y: 0.1425},
    {x: 0.0589, y: 0.1314}, {x: 0.0255, y: 0.1011}, {x: 0.0080, y: 0.0613},
    {x: 0.0143, y: 0.0151}, {x: 0.0318, y: -0.0167}, {x: 0.0541, y: -0.0406},
    {x: 0.0796, y: -0.0581}, {x: 0.1146, y: -0.0725}, {x: 0.1672, y: -0.0820},
    {x: 0.2070, y: -0.0804}, {x: 0.2516, y: -0.0677}, {x: 0.2818, y: -0.0502},
    {x: 0.3312, y: 0.0040}, {x: 0.3567, y: 0.0597}, {x: 0.3678, y: 0.1186},
    {x: 0.3662, y: 0.1632}, {x: 0.3519, y: 0.2158}, {x: 0.3264, y: 0.2604},
    {x: 0.2866, y: 0.3002}, {x: 0.2404, y: 0.3272}, {x: 0.1768, y: 0.3479},
    {x: 0.1131, y: 0.3575}, {x: 0.0414, y: 0.3575}, {x: -0.0048, y: 0.3511},
    {x: -0.0685, y: 0.3320}, {x: -0.1258, y: 0.2954}, {x: -0.1672, y: 0.2428},
    {x: -0.1975, y: 0.1696}, {x: -0.2102, y: 0.0852}, {x: -0.2038, y: 0.0056},
    {x: -0.1815, y: -0.0661}, {x: -0.1449, y: -0.1330}, {x: -0.0908, y: -0.1935},
    {x: -0.0366, y: -0.2317}, {x: 0.0478, y: -0.2635}, {x: 0.1354, y: -0.2699},
    {x: 0.2134, y: -0.2556}, {x: 0.3137, y: -0.2078}, {x: 0.3360, y: -0.2046},
    {x: 0.3631, y: -0.2269}, {x: 0.4936, y: -0.3670}, {x: 0.5000, y: -0.3798}
];

// State
const state = {
    audioContext: null,
    rasenganSound: null
};

// DOM
const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementById('output_canvas');
const ctx = canvasElement.getContext('2d');
const btn = document.getElementById('start-btn');
const loading = document.getElementById('loading');

/**
 * --------------------------------------------------------------------------
 * AUDIO ENGINE
 * --------------------------------------------------------------------------
 */
function initAudio() {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    state.audioContext = new AudioContext();

    // Wind Noise
    const bufferSize = state.audioContext.sampleRate * 2;
    const buffer = state.audioContext.createBuffer(1, bufferSize, state.audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

    const noise = state.audioContext.createBufferSource();
    noise.buffer = buffer;
    noise.loop = true;

    const filter = state.audioContext.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 500;

    const gain = state.audioContext.createGain();
    gain.gain.value = 0;

    noise.connect(filter).connect(gain).connect(state.audioContext.destination);
    noise.start();

    // Power Hum
    const osc = state.audioContext.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = 60;
    const oscGain = state.audioContext.createGain();
    oscGain.gain.value = 0;
    osc.connect(oscGain).connect(state.audioContext.destination);
    osc.start();

    state.rasenganSound = { gain, oscGain, filter };
}

function updateSound(isActive) {
    if (!state.audioContext) return;
    const t = state.audioContext.currentTime;
    
    const vol = isActive ? 0.35 : 0;
    state.rasenganSound.gain.gain.setTargetAtTime(vol, t, 0.1);
    state.rasenganSound.oscGain.gain.setTargetAtTime(isActive ? 0.2 : 0, t, 0.1);

    if (isActive) {
        state.rasenganSound.filter.frequency.setValueAtTime(500 + Math.sin(Date.now()/150)*100, t);
    }
}

/**
 * --------------------------------------------------------------------------
 * ADVANCED RASENGAN EFFECT
 * --------------------------------------------------------------------------
 */
class Rasengan {
    constructor() {
        this.active = false;
        this.x = 0;
        this.y = 0;
        this.currentRadius = 0;
        this.rotationOffset = 0;
        this.particles = [];
        for(let i=0; i<30; i++) {
            this.particles.push({
                angle: Math.random() * Math.PI * 2,
                radius: Math.random(), 
                speed: 0.05 + Math.random() * 0.1,
                size: 1 + Math.random() * 2
            });
        }
    }

    update(targetX, targetY, isActive, depthScale) {
        this.x += (targetX - this.x) * 0.2;
        this.y += (targetY - this.y) * 0.2;

        const targetRadius = isActive ? (config.rasengan.maxSize * depthScale) : 0;
        
        if (isActive) {
            this.active = true;
            this.currentRadius += (targetRadius - this.currentRadius) * config.rasengan.growthSpeed;
        } else {
            this.currentRadius += (targetRadius - this.currentRadius) * config.rasengan.shrinkSpeed;
            if (this.currentRadius < 1) this.active = false;
        }

        this.rotationOffset += 0.2; 
    }

    draw(ctx) {
        if (!this.active || this.currentRadius < 1) return;

        ctx.save();
        ctx.translate(this.x, this.y);

        ctx.globalCompositeOperation = 'screen';

        // 1. Halo
        const gradient = ctx.createRadialGradient(0, 0, this.currentRadius * 0.2, 0, 0, this.currentRadius * 1.5);
        gradient.addColorStop(0, 'rgba(200, 255, 255, 0.2)');
        gradient.addColorStop(0.5, 'rgba(0, 150, 255, 0.1)');
        gradient.addColorStop(1, 'rgba(0, 0, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, this.currentRadius * 1.5, 0, Math.PI * 2);
        ctx.fill();

        // 2. Swirls
        ctx.lineWidth = 3;
        for(let i=0; i<3; i++) {
            ctx.save();
            ctx.rotate(this.rotationOffset * (i % 2 === 0 ? 1 : -1) + (i * Math.PI / 3));
            ctx.strokeStyle = config.rasengan.colorInner;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.ellipse(0, 0, this.currentRadius, this.currentRadius * 0.4, Math.sin(this.rotationOffset*0.5), 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        // 3. Core
        const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.currentRadius);
        coreGrad.addColorStop(0, '#FFFFFF'); 
        coreGrad.addColorStop(0.4, config.rasengan.colorInner); 
        coreGrad.addColorStop(0.9, config.rasengan.colorOuter); 
        coreGrad.addColorStop(1, 'rgba(0,0,0,0)');
        
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = coreGrad;
        ctx.beginPath();
        ctx.arc(0, 0, this.currentRadius, 0, Math.PI * 2);
        ctx.fill();

        // 4. Particles
        ctx.fillStyle = '#FFF';
        this.particles.forEach(p => {
            p.angle += p.speed;
            const r = this.currentRadius * (1.2 + Math.sin(p.angle * 3) * 0.1);
            const px = Math.cos(p.angle) * r;
            const py = Math.sin(p.angle) * r;
            ctx.globalAlpha = 0.5 + Math.sin(p.angle * 5) * 0.5;
            ctx.beginPath();
            ctx.arc(px, py, p.size, 0, Math.PI * 2);
            ctx.fill();
        });

        // 5. Glow Overlay
        ctx.globalCompositeOperation = 'overlay';
        ctx.fillStyle = config.rasengan.colorOuter;
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.arc(0, 0, this.currentRadius * 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }
}

const rasengans = [new Rasengan(), new Rasengan()];

/**
 * --------------------------------------------------------------------------
 * HEADBAND RENDERER (Clean Leaf)
 * --------------------------------------------------------------------------
 */
function roundedRect(c, x, y, w, h, r) {
    c.beginPath();
    c.moveTo(x+r, y);
    c.lineTo(x+w-r, y);
    c.quadraticCurveTo(x+w, y, x+w, y+r);
    c.lineTo(x+w, y+h-r);
    c.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    c.lineTo(x+r, y+h);
    c.quadraticCurveTo(x, y+h, x, y+h-r);
    c.lineTo(x, y+r);
    c.quadraticCurveTo(x, y, x+r, y);
    c.closePath();
}

function drawHeadband(landmarks, w, h) {
    const leftTemple = { x: landmarks[103].x * w, y: landmarks[103].y * h };
    const rightTemple = { x: landmarks[332].x * w, y: landmarks[332].y * h };
    const center = { x: landmarks[10].x * w, y: landmarks[10].y * h };

    const dx = rightTemple.x - leftTemple.x;
    const dy = rightTemple.y - leftTemple.y;
    const angle = Math.atan2(dy, dx);
    const width = Math.sqrt(dx*dx + dy*dy) * 1.3;
    const height = width * 0.32;

    ctx.save();
    ctx.translate(center.x, center.y);
    ctx.rotate(angle);

    // 1. CLOTH
    ctx.fillStyle = config.headband.clothColor;
    ctx.shadowColor = 'black';
    ctx.shadowBlur = 8;
    roundedRect(ctx, -width/2, -height/2, width, height, 8);
    ctx.fill();

    // 2. METAL PLATE
    const plateW = width * 0.75;
    const plateH = height * 0.7;
    
    const grad = ctx.createLinearGradient(0, -plateH/2, 0, plateH/2);
    grad.addColorStop(0, '#ffffff'); 
    grad.addColorStop(0.2, '#e0e0e0');
    grad.addColorStop(0.5, '#b0bec5'); 
    grad.addColorStop(1, '#78909c'); 
    
    ctx.fillStyle = grad;
    ctx.shadowBlur = 0;
    roundedRect(ctx, -plateW/2, -plateH/2, plateW, plateH, 5);
    ctx.fill();
    
    ctx.strokeStyle = '#546e7a';
    ctx.lineWidth = 1;
    ctx.stroke();

    // 3. RIVETS
    ctx.fillStyle = '#37474f';
    const rivetSize = plateH * 0.08;
    for(let i=-1; i<=1; i++) {
        const yOff = i * (plateH * 0.3);
        ctx.beginPath(); ctx.arc(-plateW/2 + plateW*0.06, yOff, rivetSize, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(plateW/2 - plateW*0.06, yOff, rivetSize, 0, 6.28); ctx.fill();
    }

    // 4. KONOHA SYMBOL
    const sSize = plateH * 0.9;
    ctx.fillStyle = config.headband.symbolColor;
    ctx.beginPath();
    leafPoints.forEach((p, i) => {
        const px = p.x * sSize; 
        const py = p.y * sSize;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    });
    ctx.closePath();
    ctx.fill();

    ctx.restore();
}

/**
 * --------------------------------------------------------------------------
 * REALISTIC WHISKERS
 * --------------------------------------------------------------------------
 */
function drawWhiskers(landmarks, w, h) {
    const drawSide = (centerIdx, dir) => {
        const center = landmarks[centerIdx];
        const cx = center.x * w;
        const cy = center.y * h;
        // Face width for scaling
        const faceWidth = Math.abs(landmarks[454].x - landmarks[234].x) * w;
        const len = faceWidth * 0.18; // Slightly shorter for subtlety
        const thickness = faceWidth * 0.012; // Thinner for realism
        
        for(let i=-1; i<=1; i++) {
            const yOff = i * (faceWidth * 0.04);
            
            // Construct Path
            const path = new Path2D();
            const sx = cx - (dir * len * 0.1);
            const sy = cy + yOff;
            const ex = cx + (dir * len);
            const ey = sy + (i * faceWidth * 0.005); 

            path.moveTo(sx, sy);
            path.quadraticCurveTo(
                sx + (dir * len * 0.5), sy + (faceWidth*0.015), 
                ex, ey
            );

            // Layer 1: Subtle Indentation Highlight (Bottom edge)
            // Creates 3D depth by suggesting a ridge
            ctx.save();
            ctx.translate(0, 1);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.lineWidth = thickness * 1.2;
            ctx.lineCap = 'round';
            ctx.filter = 'blur(1px)';
            ctx.globalCompositeOperation = 'overlay'; 
            ctx.stroke(path);
            ctx.restore();

            // Layer 2: Main Mark (Soft Shadow/Pigment)
            // Uses multiply to tint the skin instead of painting over it
            ctx.save();
            ctx.strokeStyle = 'rgba(60, 45, 30, 0.5)'; // Warm dark brown
            ctx.lineWidth = thickness * 1.5;
            ctx.lineCap = 'round';
            ctx.shadowColor = 'rgba(60, 45, 30, 0.5)';
            ctx.shadowBlur = 3; 
            ctx.globalCompositeOperation = 'multiply';
            ctx.stroke(path);
            ctx.restore();
            
            // Layer 3: Core Definition
            // Thinner, darker line in the center for shape
            ctx.save();
            ctx.strokeStyle = 'rgba(40, 25, 15, 0.4)';
            ctx.lineWidth = thickness * 0.5;
            ctx.lineCap = 'round';
            ctx.globalCompositeOperation = 'multiply';
            ctx.stroke(path);
            ctx.restore();
        }
    };

    drawSide(205, -1); 
    drawSide(425, 1);  
}

// Kyuubi Eyes
function drawEyes(landmarks, w, h) {
    const drawEye = (idx1, idx2) => {
        const p1 = landmarks[idx1];
        const p2 = landmarks[idx2];
        const cx = ((p1.x + p2.x)/2) * w;
        const cy = ((p1.y + p2.y)/2) * h;
        
        ctx.save();
        ctx.translate(cx, cy);
        
        const grad = ctx.createRadialGradient(0,0, 2, 0,0, 15);
        grad.addColorStop(0, 'rgba(255, 0, 0, 0.6)');
        grad.addColorStop(1, 'rgba(255, 0, 0, 0)');
        
        ctx.fillStyle = grad;
        ctx.globalCompositeOperation = 'screen';
        ctx.beginPath(); ctx.arc(0,0, 15, 0, 6.28); ctx.fill();
        
        ctx.fillStyle = '#000';
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 0.7;
        ctx.beginPath(); ctx.ellipse(0,0, 2, 8, 0, 0, 6.28); ctx.fill();
        ctx.restore();
    };
    drawEye(159, 145); 
    drawEye(386, 374); 
}

/**
 * --------------------------------------------------------------------------
 * LOGIC LOOP
 * --------------------------------------------------------------------------
 */
function isHandOpen(lm) {
    const d = (i, j) => Math.hypot(lm[i].x - lm[j].x, lm[i].y - lm[j].y);
    let openFingers = 0;
    [8,12,16,20].forEach((tip, i) => {
        const base = [5,9,13,17][i];
        if (d(tip, 0) > d(base, 0) * 1.2) openFingers++;
    });
    if (d(4, 0) > d(2, 0) * 1.1) openFingers++;
    return openFingers >= 4;
}

let latestHands = null;
let latestFace = null;

async function startApp() {
    btn.style.display = 'none';
    loading.style.display = 'block';

    initAudio();

    const resize = () => {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
    };
    window.addEventListener('resize', resize);
    resize();

    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
    hands.onResults(res => latestHands = res);

    const faceMesh = new FaceMesh({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
    faceMesh.setOptions({maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
    faceMesh.onResults(res => latestFace = res);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await faceMesh.send({image: videoElement});
            await hands.send({image: videoElement});
            render();
        },
        width: 1280,
        height: 720
    });

    await camera.start();
    loading.style.display = 'none';
}

function render() {
    const w = canvasElement.width;
    const h = canvasElement.height;

    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.drawImage(videoElement, 0, 0, w, h);
    ctx.restore();

    // Draw Face Effects
    if (latestFace && latestFace.multiFaceLandmarks && latestFace.multiFaceLandmarks[0]) {
        const lm = latestFace.multiFaceLandmarks[0];
        drawEyes(lm, w, h);
        drawWhiskers(lm, w, h);
        drawHeadband(lm, w, h);
    }

    // Draw Hands (Rasengan)
    let activeCount = 0;
    if (latestHands && latestHands.multiHandLandmarks) {
        latestHands.multiHandLandmarks.forEach((lm, i) => {
            if (i > 1) return;
            const rasengan = rasengans[i];
            const isOpen = isHandOpen(lm);
            const cx = (lm[0].x + lm[5].x + lm[17].x)/3 * w;
            const cy = (lm[0].y + lm[5].y + lm[17].y)/3 * h;
            
            let depth = Math.abs(lm[0].y - lm[9].y) * 4; 
            depth = Math.min(Math.max(depth, 0.5), 1.5);

            rasengan.update(cx, cy, isOpen, depth);
            if(rasengan.active) activeCount++;
            rasengan.draw(ctx);
        });
    } else {
        rasengans.forEach(r => r.update(0,0,false,0));
        rasengans.forEach(r => r.draw(ctx)); 
    }

    updateSound(activeCount > 0);
}
</script>
</body>
</html>